import ast
import os
import sys
import json
import argparse
from pathlib import Path
from typing import List, Dict, Any

class McpToolVisitor(ast.NodeVisitor):
    """AST Visitor to find @mcp.tool() decorated functions"""
    def __init__(self):
        self.tools = []

    def visit_FunctionDef(self, node):
        is_tool = False
        for decorator in node.decorator_list:
            # Check for @mcp.tool() or @mcp.tool
            if isinstance(decorator, ast.Call):
                if isinstance(decorator.func, ast.Attribute) and decorator.func.attr == 'tool':
                    is_tool = True
            elif isinstance(decorator, ast.Attribute) and decorator.attr == 'tool':
                is_tool = True
        
        if is_tool:
            tool_info = {
                'name': node.name,
                'docstring': ast.get_docstring(node) or "",
                'args': []
            }
            
            # Extract arguments
            for arg in node.args.args:
                if arg.arg != 'self':  # Skip self if it's a method (though MCP tools are usually functions)
                    arg_info = {'name': arg.arg, 'type': 'str', 'default': None}
                    
                    # Try to get type annotation
                    if arg.annotation:
                        if isinstance(arg.annotation, ast.Name):
                            arg_info['type'] = arg.annotation.id
                        elif isinstance(arg.annotation, ast.Attribute):
                            arg_info['type'] = arg.annotation.attr
                            
                    tool_info['args'].append(arg_info)
            
            self.tools.append(tool_info)
        
        self.generic_visit(node)

def generate_adapter_script(tool: Dict[str, Any], mcp_file_path: Path, output_dir: Path):
    """Generate a standalone script for a tool"""
    
    script_name = f"{tool['name']}.py"
    script_path = output_dir / script_name
    
    # Calculate relative path to the original MCP file
    # We need to add the parent directory of the MCP file to sys.path
    mcp_dir = mcp_file_path.parent.resolve()
    mcp_module_name = mcp_file_path.stem
    
    # Generate click options
    options = []
    func_call_args = []
    
    for arg in tool['args']:
        # Map python types to click types
        click_type = "STRING"
        if arg['type'] == 'int':
            click_type = "INT"
        elif arg['type'] == 'bool':
            click_type = "BOOL"
            
        option_str = f"@click.option('--{arg['name'].replace('_', '-')}', help='{arg['name']}', type=click.{click_type})"
        options.append(option_str)
        func_call_args.append(f"{arg['name']}={arg['name']}")

    script_content = f"""#!/usr/bin/env python3
# /// script
# dependencies = [
#     "click",
#     "mcp",
# ]
# ///

\"\"\"
Adapter script for MCP Tool: {tool['name']}
Generated by Super Agent Monitor
\"\"\"

import sys
import json
import click
from pathlib import Path

# Add original MCP server directory to path
sys.path.append(str(Path("{mcp_dir}")))

# Import the original module
try:
    import {mcp_module_name} as original_module
except ImportError as e:
    print(f"Error importing original module: {{e}}", file=sys.stderr)
    sys.exit(1)

@click.command()
{chr(10).join(options)}
@click.option('--json', 'output_json', is_flag=True, help='Output as JSON')
def main({', '.join([a['name'] for a in tool['args']] + ['output_json'])}):
    \"\"\"
    {tool['docstring']}
    \"\"\"
    try:
        # Call the original function
        # Note: We access the function directly from the module
        # If the function is decorated, we might need to access the underlying function
        # But usually calling the decorated function works if it returns the value
        
        if hasattr(original_module, '{tool['name']}'):
            func = getattr(original_module, '{tool['name']}')
            result = func({', '.join(func_call_args)})
            
            if output_json:
                print(json.dumps(result, indent=2))
            else:
                # Simple formatted output
                print(f"Result for {tool['name']}:")
                print(json.dumps(result, indent=2))
        else:
            print(f"Function {tool['name']} not found in module", file=sys.stderr)
            sys.exit(1)
            
    except Exception as e:
        if output_json:
            print(json.dumps({{"error": str(e)}}))
        else:
            print(f"Error: {{e}}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
"""
    
    with open(script_path, 'w') as f:
        f.write(script_content)
    
    return script_name

def generate_skill_md(tools: List[Dict[str, Any]], output_dir: Path, skill_name: str):
    """Generate SKILL.md"""
    
    md_content = f"""---
name: {skill_name}
description: Auto-generated skill from MCP server. Contains tools: {', '.join([t['name'] for t in tools])}.
---

# {skill_name}

Auto-generated skill adapter for MCP Server.

## Available Scripts

"""
    
    for tool in tools:
        md_content += f"""### `scripts/{tool['name']}.py`
**Description:** {tool['docstring'].split(chr(10))[0] if tool['docstring'] else 'No description'}
**Usage:** `uv run scripts/{tool['name']}.py --help`

"""

    with open(output_dir / "SKILL.md", 'w') as f:
        f.write(md_content)

def main():
    parser = argparse.ArgumentParser(description="Convert MCP Server to Scripts/Skill")
    parser.add_argument("mcp_file", help="Path to the MCP server.py file")
    parser.add_argument("output_dir", help="Directory to output the generated files")
    parser.add_argument("--name", help="Name of the skill", default="converted-mcp-skill")
    
    args = parser.parse_args()
    
    mcp_path = Path(args.mcp_file).resolve()
    output_path = Path(args.output_dir).resolve()
    scripts_path = output_path / "scripts"
    
    if not mcp_path.exists():
        print(f"Error: File {mcp_path} does not exist")
        sys.exit(1)
        
    # Create directories
    scripts_path.mkdir(parents=True, exist_ok=True)
    
    # Parse AST
    with open(mcp_path, 'r') as f:
        tree = ast.parse(f.read())
        
    visitor = McpToolVisitor()
    visitor.visit(tree)
    
    print(f"Found {len(visitor.tools)} tools in {mcp_path.name}")
    
    # Generate Scripts
    generated_scripts = []
    for tool in visitor.tools:
        script_name = generate_adapter_script(tool, mcp_path, scripts_path)
        generated_scripts.append(script_name)
        print(f"Generated {script_name}")
        
    # Generate SKILL.md
    generate_skill_md(visitor.tools, output_path, args.name)
    print(f"Generated SKILL.md in {output_path}")
    
    # Return JSON result for the caller
    result = {
        "success": True,
        "tools": [t['name'] for t in visitor.tools],
        "output_dir": str(output_path)
    }
    print(json.dumps(result))

if __name__ == "__main__":
    main()
